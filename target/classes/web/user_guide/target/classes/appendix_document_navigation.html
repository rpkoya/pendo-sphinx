
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Appendix - Non- and Semi-Structured Document Navigation · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="appendix_using_fixed_values.html" />
    
    
    <link rel="prev" href="appendix_plugins.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./#top">
            
                    
                    Introductory Material for the Pendo Platform
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="./">
            
                <a href="./#support-portal">
            
                    
                    Support Portal
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="./">
            
                <a href="./#administration-overview">
            
                    
                    Administration Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="readme.html">
            
                <a href="readme.html#login-page">
            
                    
                    Logging in
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="./">
            
                <a href="./#when-to-use-what-a-workspace-overview">
            
                    
                    When to Use What – A Workspace Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="./">
            
                <a href="./#doc-hist">
            
                    
                    Document History
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="sourcing_data.html">
            
                <a href="sourcing_data.html#top">
            
                    
                    Sourcing Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="sourcing_data.html">
            
                <a href="sourcing_data.html#file-systems-component">
            
                    
                    Files and Folders Component
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="sourcing_data.html">
            
                <a href="sourcing_data.html#upload-component">
            
                    
                    Uploads Component
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="sourcing_data.html">
            
                <a href="sourcing_data.html#data-sources-component">
            
                    
                    Remote Sources Component
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="metadata_1.html">
            
                <a href="metadata_1.html#top">
            
                    
                    Entities and Attributes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="metadata_1.html">
            
                <a href="metadata_1.html#entities-component">
            
                    
                    Entities Component
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="document-set-class.html">
            
                <a href="document-set-class.html#top">
            
                    
                    Document Sets and Document Classes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="document-set-class.html">
            
                <a href="document-set-class.html#docset-component">
            
                    
                    Document Sets
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="document-set-class.html">
            
                <a href="document-set-class.html#classification">
            
                    
                    Document Classes Component
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="ocr-screens.html">
            
                <a href="ocr-screens.html#top">
            
                    
                    OCR related screens and Confidence numbers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="class-stats.html">
            
                <a href="class-stats.html#top">
            
                    
                    Classification Statistics
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="unified_search.html">
            
                <a href="unified_search.html#top">
            
                    
                    Unified Search
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="appendix_high_level_behaviors.html">
            
                <a href="appendix_high_level_behaviors.html#top">
            
                    
                    Appendix - All About Grids: Sorting, Filtering, Grouping and more.
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="appendix_plugins.html">
            
                <a href="appendix_plugins.html#top">
            
                    
                    Appendix – Data Plugins - General Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="appendix_document_navigation.html">
            
                <a href="appendix_document_navigation.html#top">
            
                    
                    Appendix - Non- and Semi-Structured Document Navigation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="appendix_using_fixed_values.html">
            
                <a href="appendix_using_fixed_values.html#top">
            
                    
                    Appendix – Using Fixed Values including Approved List of Values during Classification Mapping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="appendix_using_excel_plugin.html">
            
                <a href="appendix_using_excel_plugin.html#top">
            
                    
                    Appendix - Using the Excel Plugin for Classification
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="appendix_advanced_data_extraction.html">
            
                <a href="appendix_advanced_data_extraction.html#top">
            
                    
                    Appendix - Classification - Advanced Data Extraction Examples
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="appendix_date_time.html">
            
                <a href="appendix_date_time.html#top">
            
                    
                    Appendix - Date and Time Formatting and Parsing Options
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="appendix_api_naming.html">
            
                <a href="appendix_api_naming.html#api-naming">
            
                    
                    Appendix - API Naming
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Appendix - Non- and Semi-Structured Document Navigation</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="top">Appendix - Navigating Unstructured Data </h1>
<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#gen-nav">General Navigation Concepts</a><ul>
<li><a href="#nav-basic">Node Navigation Basics</a><ul>
<li><a href="#node-by-type">Node organization based on File Type</a></li>
<li><a href="#nav-text">Text documents Node Structure</a></li>
<li><a href="#nav-word">Word Document Structure</a></li>
<li><a href="#nav-table">Table Structure</a></li>
</ul>
</li>
<li><a href="#adv-node-concepts">Advanced Node Concepts</a><ul>
<li><a href="#int-summ">Interface Summary</a></li>
<li><a href="#class-summ">Class Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#node-examples">Node Based Examples</a><ul>
<li><a href="#node-word-example">Navigating in Word using Nodes</a><ul>
<li><a href="#word-test-doc">Test Document</a></li>
<li><a href="#word-nav-syntax">Bracket Navigation Syntax</a></li>
<li><a href="#word-nlp">Language Navigation</a></li>
<li><a href="#word-part-of-speech">Parts of Speech</a></li>
<li><a href="#word-column">Column Navigation</a></li>
<li><a href="#word-table">Table Navigation</a></li>
<li><a href="#word-regex">Regex Navigation</a></li>
<li><a href="#word-find">Find Navigation</a><ul>
<li><a href="#find-seg">findSegment Navigation</a></li>
<li><a href="#find-prev">findPrevious Navigation</a></li>
<li><a href="#find-loc">findLocation Navigation</a></li>
<li><a href="#word-then-number">Find a word then find a number</a></li>
</ul>
</li>
<li><a href="#word-type">Type Navigation</a><ul>
<li><a href="#word-token">Token navigation</a></li>
<li><a href="#word-sentence">Sentence Navigation</a></li>
<li><a href="#word-word">Word Navigation</a></li>
<li><a href="#word-person">Person Navigation</a></li>
<li><a href="#word-org">Organization Navigation</a></li>
<li><a href="#word-date">Date Navigation</a></li>
<li><a href="#word-money">Money Navigation</a></li>
<li><a href="#word-pct">Percentage Navigation</a></li>
<li><a href="#word-seg">Segment Navigation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#syntax">Show me the syntax!</a><ul>
<li><a href="#nav-by-node">Navigation by node</a></li>
<li><a href="#word-nav-by-text">Navigation by text</a></li>
<li><a href="#nav-by-num">Navigation by numbers</a></li>
<li><a href="#nav-by-string">Navigation by string</a></li>
<li><a href="#nav-by-list">Navigation by lists</a></li>
<li><a href="#nav-misc">Misc. Navigation</a></li>
</ul>
</li>
<li><a href="#brack-nlp">Some Common Navigation using Brackets and NLP</a><ul>
<li><a href="#brac-examp">Examples:</a><ul>
<li><a href="#from-root">From root:</a></li>
<li><a href="#from-node">From any node:</a></li>
<li><a href="#from-text-node">From any text node (paragraph, cell or extracted text segment):</a></li>
<li><a href="#from-table">From tables:</a></li>
<li><a href="#from-rows">From rows:</a></li>
<li><a href="#from-cells">From cells:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-nav-feat">Advanced Navigation Features</a><ul>
<li><a href="#java-var">JAVA Variable Declarations</a><ul>
<li><a href="#java-declare">Declaring a variable</a></li>
<li><a href="#java-parse">Date Parsing and Date Arithmetic</a></li>
<li><a href="#java-branch">Conditional Branching</a></li>
</ul>
</li>
<li><a href="#elvis">The Elvis Operator</a></li>
<li><a href="#safe">Safe Navigation</a></li>
<li><a href="#spEl">spEl Examples</a></li>
</ul>
</li>
</ul>
<h1 id="intro">Introduction </h1>
<p>The following is an overview for <em>Classification Marker</em> and <em>Mapping Navigation</em> capabilities.  </p>
<p>As you have read previously, the purpose of the <em>Classification</em> component is to target <em>Non- or Semi-Structured Data Sources</em> such as Word, Excel, Text or imaged documents, search thru them and extract, and possibly manipulate, data otherwise trapped in these files.  <strong>In other word, creating structured data from unstructured sources.</strong></p>
<p><strong>A few definitions</strong>:</p>
<p><em>Structured Data</em>, a.k.a databases, first depends on creating a data model &#x2013; a model of the types of business data that will be recorded and how they will be stored, processed and accessed. For most legacy databases, this includes defining what fields of data will be stored and how that data will be stored: data type (numeric, currency, alphabetic, name, date, address) and any restrictions on the data input (number of characters; restricted to certain terms such as Mr., Ms. or Dr.; M or F).  These types of databases are usually tightly connected with some version of SQL.  More modern databases are classified as a NoSql database program. For example, MongoDB uses JSON-like documents that have schemas.</p>
<p><em>Unstructured Data</em> files often include text, tables and even multimedia content. Variations of this term include <em>Non-Structured</em> and <em>Semi-Structured</em> data.  Examples include e-mail messages, word processing documents, spreadsheets, presentations, webpages and many other kinds of business documents. The term <em>Semi-Structured</em> implies that some of these files can have some degree of internal structure. If you think of an email, you can see that there is a &#x2018;To:&#x2019; field, a &#x2018;From:&#x2019; field, &#x2018;Subject:&#x2019; Line, &#x2018;Body:&#x2019; and so on.  A word document may have embedded tables, paragraphs, and so on. They are still not considered <em>Structured</em> because the data they contain doesn&apos;t fit neatly in a database.</p>
<p><strong>Experts estimate that 80 to 90 percent of the data in any organization is unstructured and the amount of unstructured data in enterprises is growing significantly &#x2014; often many times faster than structured databases.</strong>  </p>
<p>The <em>PD<sup>3</sup>P</em> has adopted a multi-pronged approach to dealing with navigation and the targeting of data that was previously locked up in these <em>Non-</em> and <em>Semi-Structured</em> documents:</p>
<ol>
<li>A universal navigation syntax using the concept of nodes (explained below).</li>
<li>Special functions available via dropdown for certain type of data. For example,  <em>Anchor/Offset</em> or <em>Triangulated</em> data.</li>
<li>Specialized <em>helpers</em>, such as dateHelper, that assist and provide flexibility to certain types of data.</li>
<li>Access to powerful industry standard expression tools such as JAVA RegEx and Spring Expression Language (spEl). Options such as <em>Anchor/Offset, Triangulation</em> and <em>helpers</em> are constantly being added to the <em>PD<sup>3</sup>P</em>, however there is tremendous power in writing advanced expressions to search and navigate around a file in order to target and manipulate data to be extracted and aggregated.  </li>
</ol>
<p>The Node approach capability incorporates:</p>
<ul>
<li>Text files which result from importing PDFs or scanned image data.  </li>
<li>MS Word&#xA9; (includes Word2003, Word2003xml and Word 2010 variations).  </li>
<li>In the near future, Excel will be folded into the node approach. For now, Excel navigation currently has its own navigation model.  </li>
</ul>
<p><strong>Additional Material</strong><br>The <em>Pendo Digital Data Discovery Platform</em> capabilities are modified and expanded quite frequently. The examples previded below are only a subset of the full capabilites of the <em>Platform</em>.  Full JAVADOC documentation can be found at <strong>URL:XXXXXXXX.placeholder</strong></p>
<p>Regular Expressions (RegEx) are a very powerful industry standard tool to aid in complex queries.  Please go to <a href="http://www.regular-expressions.info/" target="_blank">Regular Expression Reference Page</a> for all available syntax options.  This is a very feature rich syntax.  Please be sure to select Java as the flavor of RegEx.  </p>
<p> The full capabilities of the Spring Expression Language (SpEL) is also available, providing additional powerful functions. Please refer to [Spring Expression Language (SpEL)] (<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html" target="_blank">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html</a>)  </p>
<p><a href="#top">Top of Section</a>  </p>
<h1 id="gen-nav">General Navigation Concepts </h1>
<p>What do we mean by document navigation? In the context of unstructured data this means searching and moving around a file such as a Word document with the ultimate goal of extracting and/or manipulating specific data and putting it into a table.  In other words, creating structured data from unstructured sources.<br>The <em>PD<sup>3</sup>P</em> supports this sophisticated handling and manipulation of unstructured data. Beyond being able to search through any mixture of unstructured and structured data, you can extract and even manipulate data so that you can meet regulatory requirements, internal risk assessments and generally perform analysis and/or send the extracted information to other systems on your network.  The <em>PD<sup>3</sup>P</em> also tracks all rules and datasets used so that there is a record of &apos;data hops&apos;, meaning that you can see what data looked like and what actions were performed from the source document until extraction is complete.</p>
<p>A simple example of navigation would be to search for the words &#x2018;Credit Score&#x2019;, and then find the next value to the right so that it can be extracted.
For example a very simple text file might look like this:</p>
<table>
<thead>
<tr>
<th>Prepared:</th>
<th>Jan 31, 2017</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Credit Score for:</strong></td>
<td><strong>John Smith </strong></td>
</tr>
<tr>
<td><strong>As Of:</strong></td>
<td><strong>Jan 17, 2017</strong>  </td>
</tr>
<tr>
<td><strong>Credit Score:</strong></td>
<td><strong>700</strong>   </td>
</tr>
</tbody>
</table>
<p>What you may wish to extract is the person&#x2019;s name, &#x2018;As Of&#x2019; date and the credit score.  However, you have 21 million files like this. Further, you may wish to reformat the date from &#x2018;mmm dd, yyyy&#x2019; to &#x2018;mm-dd-yyyy&#x2019; (1-17-2017) and break out &#x2018;John Smith&#x2019; into two fields of Last Name and First Name.  </p>
<p>You will find when dealing with large volumes of data created over time that the formats change. For example:   </p>
<table>
<thead>
<tr>
<th>Prepared:</th>
<th>Jan 31, 2017</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Credit Score for:</strong></td>
<td><strong>John Smith </strong></td>
</tr>
<tr>
<td><strong>Previous Score</strong></td>
<td><strong>650</strong></td>
<td><strong>Previous As of:</strong></td>
<td><strong>November 15, 2016*</strong></td>
</tr>
<tr>
<td><strong>As Of:</strong></td>
<td><strong>Jan 17, 2017</strong>  </td>
</tr>
<tr>
<td><strong>Credit Score:</strong></td>
<td><strong>700</strong>   </td>
</tr>
</tbody>
</table>
<p>You may want to include or disregard the previous score whenever it is available. This concept of dealing with source files changing over time is core to the success of most of these types of projects.</p>
<p>A few other examples:</p>
<ul>
<li>You may want to search for a specific table in a Word document that has several tables and extract the data in the in the second row, 8th column.</li>
<li>You may want to search for 5th persons name in a document and extract the name and address.</li>
<li>You may want to find and extract the first, second and fifth occurrences of a company name in a PDF.</li>
<li>You may want to open a spreadsheet, find a specific worksheet, then find the 3rd time the Word &#x2018;Retail&#x2019; appears and then get the next 5 column of data to the right that are not empty.</li>
</ul>
<p>As you can see, the possibilities are endless.</p>
<p><a href="#top">Top of Section</a>  </p>
<h2 id="nav-basic">Node Navigation Basics </h2>
<p>One of the <em>PD<sup>3</sup>P</em> approaches navigation using a node-based concept. This is applied no matter the type of file you are navigating.  You move and search through a tree of nodes where each node has a parent and an ordered list of children.</p>
<p>For example, if you start at the top of a Word document, you may wish to go to the second paragraph (a node) and then search for and extract a Person&#x2019;s Name that is somewhere in the paragraph (text segment).</p>
<p>A more complex example would starting from the top of a Word document (root node), you may want to search for the second table (which is a table node)  and then find the row (row node) that starts with the words &#x2018;Credit Score&#x2019;. You could then further navigate by finding the next cell to the right (a cell node) which is not blank, get that value, trim it (for example $10 becomes 10) and extract that to a <em>Target Entity</em>.</p>
<p>This gets easier with a bit of practice, especially as the syntax used is common no matter the type of file with which you are dealing.  </p>
<p><a href="#top">Top of Section</a>  </p>
<h3 id="node-by-type">Node organization based on File Type </h3>
<p>While the concept of moving around nodes is universal in various types of files, exactly what a node is depends on the type of file being used and where you are in navigating that document. Below, each arrow shows the hierarchy of nodes for each file type and ending with text or text-segments. The topmost node, known as the root node, is always the document (PDF, Excel, Word, etc.) itself.</p>
<p><img src="appendix_unstructured_navigation/68785f2f7b69832564e0f3d30ae3e1de.png" alt="">  </p>
<p><a href="#top">Top of Section</a>  </p>
<h3 id="nav-text">Text documents Node Structure </h3>
<p>A Text file results from importing PDFs or image files.  During <em>Import</em>, you would have used the &#x2018;PDF to Text&#x2019; or &#x2018;Google Tesseract OCR&#x2019; plugin along with the &#x2018;Text Classification/Parser&#x2019; Plugin.  </p>
<ul>
<li>The Text Document is the Root Node and contains a list of children nodes that are called Lines (think of lines of text).  </li>
<li>A text document does not have paragraphs or table nodes, rather it has &apos;lines&apos;.  It is a completely unstructured data file.  </li>
<li>Lines contains lists of characters. Child text-segment nodes can be extracted i.e. sentences, tokens, dates, etc. These segments are child nodes of the parent line.</li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-word">Word Document Structure </h3>
<ul>
<li>The Word document is the root node and contains a list of children: paragraphs and tables.</li>
<li>Paragraph contains lists of characters which can be treated as various text-segments.  Child text segment nodes can be extracted from a paragraph, i.e. sentences, tokens, dates, names, organizations, parts of speech, etc. These segments are child nodes of the parent paragraph.</li>
<li>A Table Node contains list of child rows, and each row contains list of child cells.<ul>
<li>Like paragraphs, a cell contains list of characters which can be treated as various text-segments which can be extracted from cells.</li>
</ul>
</li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-table">Table Structure </h3>
<ul>
<li>Tables are unique in that both Excel and Word can used the same concepts of Table Nodes.</li>
<li>For Excel, the Excel document is the Root Node and contains a list of children: sheets, rows, columns and cells.</li>
<li>For Word, the Word document is the Root Node and a Table is a child node</li>
<li>The Nodes in Excel are the same as within a table in Word with the following exception:<ul>
<li>In Excel, Sheet (a.k.a. Worksheet) is the node level directly under the Root Node.  A Word document does not have sheets.</li>
</ul>
</li>
<li>A Table node contains list of child rows, and each row contains list of child columns and cells.</li>
<li>Like paragraph, a cell contains list of characters which can be treated as various types of text-segments.  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h2 id="adv-node-concepts">Advanced Node Concepts </h2>
<p>For people with some programming background or who are familiar with Excel macros, the following information provides additional insights.
The concept of Nodes, Text, Natural Language Processing (NLP) and Types cuts across all files types supported on the PD<sup>3</sup>P. Most of the navigation options fall into the following object types:</p>
<ul>
<li>Node - for navigating to parent, sibling and children or finding descendants by regex or named entity like person or date.</li>
<li>Collection of Nodes - for retrieving child from list, getting a slice of the list or finding child by RegEx or Named Entity.</li>
<li>Text - for navigating, slicing, extracting or finding RegEx or Named Entities in text.</li>
<li>NLP &#x2013; (Natural Language Processing) for finding text based on analysis of natural language, e.g. Named Entities like person, organization, date, etc.</li>
<li>Type &#x2013; search for a type of data including:</li>
</ul>
<table>
<thead>
<tr>
<th>Types of Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>column</td>
<td>date</td>
</tr>
<tr>
<td>location</td>
<td>money</td>
</tr>
<tr>
<td>number</td>
<td>organization</td>
</tr>
<tr>
<td>percentage</td>
<td>person</td>
</tr>
<tr>
<td>phrase</td>
<td>root</td>
</tr>
<tr>
<td>sentence</td>
<td>time</td>
</tr>
<tr>
<td>token</td>
<td>word</td>
</tr>
</tbody>
</table>
<h3 id="int-summ">Interface Summary </h3>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node</td>
<td>Ordered node in the document tree.</td>
</tr>
<tr>
<td>NodeCollection</td>
<td>An ordered list of node children</td>
</tr>
<tr>
<td>Table</td>
<td>A Node that represents a two-dimensional grid of rows containing cells</td>
</tr>
<tr>
<td>TableCell</td>
<td>Cell in a row</td>
</tr>
<tr>
<td>TableRow</td>
<td>A row in a table containing cells</td>
</tr>
<tr>
<td>Text</td>
<td>A node that contains text such as a paragraph, line or cell.</td>
</tr>
</tbody>
</table>
<h3 id="class-summ">Class Summary </h3>
<table>
<thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CharacterNode</td>
<td>A code that represents a single character in a string of text</td>
</tr>
<tr>
<td>TextCollection</td>
<td>A collection of text nodes</td>
</tr>
<tr>
<td>TextSegment</td>
<td>Represents a segment of text within a string  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h1 id="node-examples">Node Based Examples </h1>
<h2 id="node-word-example">Navigating in Word using Nodes </h2>
<h3 id="word-test-doc">Test Document </h3>
<p>Below is a test document that will be used for showing the results of a <em>Word Expression Mapping</em> in <em>Classification</em>.  The layout of the sample document between the two dashed horizontal lines below. In this document we have:<br>&#x2022;    Paragraphs - any line or group of sentences not in a table that have a linefeed (a.k.a carriage return) after it.<br>&#x2022;    Tables &#x2013; these are simple two row/two column tables.<br>&#x2022;    Names of people and organizations.<br>&#x2022;    Money and number example.<br>&#x2022;    Notice the line &#x201C;This is another line   with columns   working. &#x201C; has some weird spacing.   If you have words that have more than one blank space between them, they can optionally be treated as being in columns.  </p>
<p>After that, over forty examples describe the navigation goal, the syntax and the result of that syntax.  </p>
<p>And below that you have a list of many of the syntax options available to you.  </p>
<p>And below that you have some complex examples to show the non-node methods of  RegEx and spEl expressions for advanced users.  
&#x2003;</p>
<hr>
<p>First paragraph.<br>Second paragraph.<br>Third paragraph.<br>Find me1</p>
<table>
<thead>
<tr>
<th>Name: Tom</th>
<th>Find me2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Find me3</strong></td>
<td><strong>Credit Score: 700</strong></td>
</tr>
</tbody>
</table>
<p>Find me4<br>Here&#x2019;s a paragraph with a lot of words. We&#x2019;ve got a meeting on January 10, 2017. Let&#x2019;s see how well OpenNLP works! My friend who works at Acme Bank owes me $10 for dinner. I would estimate a 90% chance of being paid.<br>This is another line &#xA0; &#xA0; with columns &#xA0; &#xA0; working.<br>Cheese balls  (45555)    -123,323  23,2333</p>
<table>
<thead>
<tr>
<th>Name: Dick</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>Credit Score: 750</strong></td>
</tr>
</tbody>
</table>
<p>101 Main St, Charlotte, NC 28203.<br>Blah blah blah.<br>Find me5<br>Blah blah blah.  </p>
<table>
<thead>
<tr>
<th>Name: Harry</th>
<th>Find me6</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Find me7</strong></td>
<td><strong>Credit Score: 800</strong></td>
</tr>
</tbody>
</table>
<p>I have $1,123,123.123 in the bank.<br>Blah blah blah.<br>Find me8<br>Last paragraph.  </p>
<hr>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-nav-syntax">Bracket Navigation Syntax </h3>
<p>Here you will see the navigation goal, the syntax used, the result of the expression and, notes as needed.  </p>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Starting at the root node, get 1st node from the 2nd character onwards.</td>
<td>[&apos;0&apos;][&apos;1:&apos;]</td>
<td>irst paragraph.</td>
<td>Note 1: The first node in a word document is the first paragraph. A paragraph is a group of words/sentences, etc. with a carriage return at the end. Paragraphs can be vary large or just one word.  Note 2: Remember everything is zero indexed, meaning 0 is the first, 1 is the second and so on. Note 3:  When specifying the first or last characters, a number is not needed, thus [&#x2018;1:&#x2019;] means from second to last, and [&#x2018;:3] would mean from first to 4th.  Note 4: within brackets that use colons, e.g. [&#x2018;1:3&#x2019;], the last digit is a penultimate digit.  The definition of penultimate is something that is second to last or right before the last item in a series. An example of penultimate is the letter &quot;Y&quot; which is the second to last letter in the alphabet.  If you have a sentence that ends with a period, the penultimate character would be whatever is right before the period.</td>
</tr>
<tr>
<td>Get 1st node, then first character onwards to 5th character</td>
<td>[&apos;0&apos;][&apos;:5&apos;]</td>
<td>First  </td>
</tr>
<tr>
<td>get 1st node, then first character onwards to 5th character from end</td>
<td>[&apos;0&apos;][&apos;-5:&apos;]</td>
<td>raph.</td>
<td>Note 1: The use of negative numbers mean go to the end of the current node and move backwards.  -1 means the last item, -5 means the 5th from last. In this example, we start at -5, so 5th from last.  There is nothing after the colon, so that means go to the last. Note 2: characters include punctuation, thus you would get the period being the last character in this paragraph.</td>
</tr>
<tr>
<td>get 1st node, then first character to 2nd character</td>
<td>[&apos;0&apos;][&apos;0:2&apos;]</td>
<td>Fi</td>
<td>Note: At first blush, the number 2 above might make you think you would get three characters since everything is 0 indexed. But remember the digit after the colon is penultimate (not inclusive), so in fact you get &#x2018;Fi&#x2019; not &#x2018;Fir&#x2019;.</td>
</tr>
<tr>
<td>get 1st node, then first character to penultimate character</td>
<td>[&apos;0&apos;][&apos;0:-1&apos;]</td>
<td>First paragraph</td>
<td>Note: If you thought you would get the period at the end as well as &#x2018;First paragraph&#x2019;, you forgot penultimate logic. -1 means the second to last.   If you want the punctuation, see below.</td>
</tr>
<tr>
<td>get 1st node, then first character to last character</td>
<td>[&apos;0&apos;][&apos;:&apos;]</td>
<td>First paragraph.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-nlp">Language Navigation </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find the string &apos;Open NLP&apos; then find the next word</td>
<td>findWord(&apos;OpenNLP&apos;, 1).next(&apos;word&apos;)</td>
<td>works</td>
</tr>
<tr>
<td>find first occurrence of word OpenNLP, then next organization</td>
<td>findWord(&apos;OpenNLP&apos;).next(&apos;organization&apos;)</td>
<td>Acme Bank</td>
</tr>
<tr>
<td>find first occurrence of word Bank, then next money</td>
<td>findType(&apos;word&apos;, &apos;Bank&apos;, 1).next(&apos;money&apos;)</td>
<td>$10</td>
</tr>
<tr>
<td>find first occurrence of word Bank, then next money, then previous organization</td>
<td>findWord(&apos;Bank&apos;).next(&apos;money&apos;).previous(&apos;organization&apos;)</td>
<td>Acme Bank</td>
</tr>
<tr>
<td>find first occurrence of word Bank, then next money, then previous organization, then previous word</td>
<td>findWord(&apos;Bank&apos;).next(&apos;money&apos;).previous(&apos;organization&apos;).previousWord()</td>
<td>at</td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-part-of-speech">Parts of Speech </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of text segment &apos;I have&apos;, then first word from start of segment, then analyze simple part of speech</td>
<td>find(&apos;I have&apos;).nextWord(0).simplePartOfSpeech</td>
<td>PRONOUN</td>
<td>Note:  after finding &#x2018;I have&#x2019;, the pointer is at the beginning of the text segment, thus pointing at &#x2018;I&#x2019;.  nextWord (0) stays right there  and specifically finds  &#x2018;I&#x2019;, which  is a pronoun.</td>
</tr>
<tr>
<td>find first occurrence of text segment &apos;I have&apos;, then second (next 1) word from start of segment, then analyze simple part of speech</td>
<td>find(&apos;I have&apos;).nextWord(1).simplePartOfSpeech</td>
<td>VERB</td>
<td>Note: after finding &#x2018;I have&#x2019;, the pointer is at the beginning of the test segment, thus pointing at &#x2018;I&#x2019;.  Moving one word forward specifically finds &#x2018;have&#x2019;, which is a verb.</td>
</tr>
<tr>
<td>find first occurrence of text segment &apos;I have&apos;, then next number, then get text type</td>
<td>findSegment(&apos;I have&apos;).nextNumber().getTextType()</td>
<td>NUMBER  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-column">Column Navigation </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first node containing &apos;another line&apos;, then next column</td>
<td>find(&apos;another line&apos;).nextColumn()</td>
<td>with columns</td>
<td>Note: when dealing with text, you can treat more than one consecutive space as an indication of moving from one column to the next.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-table">Table Navigation </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find 5th node, 1st row, 1st cell, 7th letter to 9th letter</td>
<td>[&apos;4&apos;][&apos;0&apos;][&apos;0&apos;][&apos;6:9&apos;]</td>
<td>Tom  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-regex">Regex Navigation </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>find node that starts with S and ends with d</td>
<td>[&apos;S\w+d&apos;]</td>
<td>Second paragraph</td>
<td>Note:  finds the word &#x2018;Second&#x2019; which is part of a Text Segment and returns the entire segment.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-find">Find Navigation </h3>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first node that contains &apos;Find me&apos;</td>
<td>find(&apos;Find me&apos;)</td>
<td>Find me1</td>
</tr>
<tr>
<td>find the first occurrence of an node that contains &apos;Find me&apos;</td>
<td>find(&apos;Find me&apos;, 2)</td>
<td>Find me2</td>
</tr>
<tr>
<td>find 7th node that contains &apos;Find me&apos;, go 0 cells forward and 1 row up, extract text after &apos;Name: &apos;</td>
<td>find(&apos;Find me&apos;, 7).go(0,-1).extract(&apos;Name:(.*)&apos;)</td>
<td>Harry</td>
</tr>
<tr>
<td>find 6th node that contains &apos;Find me&apos;, go 1 cell backward and 0 rows up, extract text after &apos;Name:&apos;</td>
<td>find(&apos;Find me&apos;, 6).go(-1,0).extract(&apos;Name: (.*)&#x2019;)</td>
<td>Harry  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="find-seg">findSegment Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find text segment that contains &apos;Main&apos;, get next work</td>
<td>findSegment(&apos;Main&apos;).nextWord()</td>
<td>St  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="find-prev">findPrevious Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find 7th node that contains &apos;Find me&apos;, find relative previous 5th occurrence of &apos;Find me&apos;, go 1 cell backward and 0 rows up, extract text after &apos;Name: &apos;</td>
<td>find(&apos;Find me&apos;, 7).findPrevious(&apos;Find me&apos;, 5).go(-1,0).extract(&apos;Name: (.*)&#x2019;)</td>
<td>Tom  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="find-loc">findLocation Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find &apos;Find me5&apos;, find previous location that contains &apos;harlot&apos;</td>
<td>find(&apos;Find me5&apos;).findPreviousType(&apos;location&apos;, &apos;harlot&apos;, 1)Charlotte</td>
</tr>
<tr>
<td>find &apos;Find me5&apos;, find 2nd previous location</td>
<td>find(&apos;Find me5&apos;).findPreviousType(&apos;location&apos;, 2)</td>
<td>Main St</td>
</tr>
<tr>
<td>find &apos;Find me4&apos;, find next location</td>
<td>find(&apos;Find me4&apos;).findNextType(&apos;location&apos;, 1)</td>
<td>Main St</td>
</tr>
<tr>
<td>find &apos;Find me4&apos;, find next 2nd location</td>
<td>find(&apos;Find me4&apos;).findNextType(&apos;location&apos;, 2)</td>
<td>Charlotte</td>
</tr>
<tr>
<td>find &apos;Find me4&apos;, find next location containing &apos;ain&apos;, then find next location relative to that</td>
<td>find(&apos;Find me4&apos;).findNextType(&apos;location&apos;, &apos;ain&apos;).findNextType(&apos;location&apos;)</td>
<td>Charlotte</td>
</tr>
<tr>
<td>find &apos;Find me4&apos;, find next location, then find next location relative to that</td>
<td>find(&apos;Find me4&apos;).findNextType(&apos;location&apos;).next(&apos;location&apos;)</td>
<td>Charlotte  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-then-number">Find a word then find a number </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find node that contains  &apos;Third&apos;, go forward 2 to table, get 2nd row, find cell that contains with Credit Score, 15th char onwards</td>
<td>[&apos;Third&apos;].go(2)[&apos;1&apos;][&apos;Credit&apos;][&apos;14:&apos;]</td>
<td>700</td>
</tr>
<tr>
<td>find node that contains Tom&apos;, go forward 1 cell and down 1 row, extract credit score</td>
<td>find(&apos;Tom&apos;).go(1,1).extract(&apos;Credit Score: (.*)&apos;)</td>
<td>700</td>
</tr>
<tr>
<td>find node that contains &apos;Tom&apos;, go forward 1 cell and down 1 row, get 15th through 17th characters</td>
<td>find(&apos;Tom&apos;).go(1,1)[&apos;14:17&apos;]</td>
<td>700  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-type">Type Navigation </h3>
<h4 id="word-token">Token navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find node that contains &apos;OpenNLP&apos;, get 3rd token</td>
<td>[&apos;OpenNLP&apos;].tokens[&apos;2&apos;]</td>
<td>paragraph  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-sentence">Sentence Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find node that contains &apos;OpenNLP&apos;, get 2nd sentence</td>
<td>[&apos;OpenNLP&apos;].sentences[&apos;1&apos;]</td>
<td>We&#x2019;ve got a meeting on January 10, 2017.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-word">Word Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find node that contains &apos;OpenNLP&apos;, get first word</td>
<td>[&apos;OpenNLP&apos;].words[&apos;0&apos;]</td>
<td>Here&#x2019;s</td>
</tr>
<tr>
<td>find node that contains &apos;OpenNLP&apos;, get second sentence, second word</td>
<td>[&apos;OpenNLP&apos;].sentences[&apos;1&apos;].words[&apos;1&apos;]</td>
<td>got</td>
</tr>
<tr>
<td>find node that contains &apos;OpenNLP&apos;, get second sentence, second word, go 6 characters backwards</td>
<td>[&apos;OpenNLP&apos;].sentences[&apos;1&apos;].words[&apos;1&apos;].go(&apos;-6&apos;)</td>
<td>W  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-person">Person Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of a person</td>
<td>findType(&apos;person&apos;)</td>
<td>Tom  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-org">Organization Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of an organization</td>
<td>findType(&apos;organization&apos;)</td>
<td>Acme Bank  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-date">Date Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of a date, then format it</td>
<td>findType(&apos;date&apos;).formatDate(&apos;dd-MMM-yyyy&apos;)</td>
<td>10-Jan-2017  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-money">Money Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of money</td>
<td>findType(&apos;money&apos;)</td>
<td>$10  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-pct">Percentage Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find first occurrence of percentage</td>
<td>findType(&apos;percentage&apos;)</td>
<td>90%  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h4 id="word-seg">Segment Navigation </h4>
<table>
<thead>
<tr>
<th>Goal &#x2013; what are we trying to do?</th>
<th>Syntax</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td>find segment &apos;in the bank&apos; and get previous word</td>
<td>findSegment(&apos;in the bank&apos;).previousWord(1)</td>
<td>1,123,123.123</td>
</tr>
<tr>
<td>find segment &apos;in the bank&apos; and get previous number</td>
<td>findSegment(&apos;in the bank&apos;).previousNumber(1).cleanedValue</td>
<td>1123123.123</td>
</tr>
<tr>
<td>find segment &apos;in the bank&apos; and get previous number and do some arithmetic</td>
<td>findSegment(&apos;in the bank&apos;).previousNumber().decimal + 1.001</td>
<td>1123124.124  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h2 id="syntax">Show me the syntax! </h2>
<p>The expression you actually type in can use either brackets or words to find and move around.  Here you see a subset of the entire syntax available to you that you can refer to as needed.</p>
<p>At first blush this can be daunting.   Do not worry about memorizing the commands.  Refer back to them as needed and you will become familiar with the one you need the most.  </p>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-by-node">Navigation by Node </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node</td>
<td>findNext(String regex)</td>
<td>Finds the first Node recursively in the document tree, matching the given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findNext(String regex, int nth)</td>
<td>Finds the next Node recursively in the document tree at nth occurrence matching the given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findNextType(String type, String regex)</td>
<td>Finds the next first Node recursively in the document tree of given type and matching given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findNextWord(String regex)</td>
<td>Finds next word matching given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findPrevious(String regex)</td>
<td>Finds the first Node recursively in the document tree that matches given expression, going backwards from current Node</td>
</tr>
<tr>
<td>Node</td>
<td>findPreviousType(String type)</td>
<td>Finds the first Node recursively in the document tree of given type, going backwards from current Node</td>
</tr>
<tr>
<td>Node</td>
<td>findPreviousType(String type, String regex)</td>
<td>Finds the first Node recursively in the document tree of given type and matching given regex, going backwards from current Node</td>
</tr>
<tr>
<td>Node</td>
<td>findPreviousType(String type, String regex, int nth)</td>
<td>Finds the Node recursively in the document tree, at nth occurrence of given type, going backwards from current Node</td>
</tr>
<tr>
<td>Node</td>
<td>findPreviousWord(String regex)</td>
<td>Finds previous word matching given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findPreviousWord(String regex, int nth)</td>
<td>Finds previous nth occurrence of a word matching given regex</td>
</tr>
<tr>
<td>NodeCollection</td>
<td>find(String regex)</td>
<td>Finds regex within this Text.  XXXXX refer to types  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="word-nav-by-text">Navigation by text </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Text</td>
<td>down()</td>
<td>Gets segment of next sibling, where the start and end are the same this text</td>
</tr>
<tr>
<td>Text</td>
<td>findNextSegment(String regex)</td>
<td>Finds the next text segment matching the given regex</td>
</tr>
<tr>
<td>Text</td>
<td>findNextSegment(String regex, int nth)</td>
<td>Finds the nth occurrence of next text segment matching the given regex</td>
</tr>
<tr>
<td>Node</td>
<td>findNextType(String type)</td>
<td>Finds the next nth occurrence of a Node recursively in the document tree of given type</td>
</tr>
<tr>
<td>Text</td>
<td>findSegment(String regex)</td>
<td>Finds text segment matching given regex with segment starting and ending at start and end of the match</td>
</tr>
<tr>
<td>Text</td>
<td>getNumber()</td>
<td>Gets first number in this text</td>
</tr>
<tr>
<td>Text</td>
<td>getSentence()</td>
<td>Gets first sentence in this text</td>
</tr>
<tr>
<td>Text</td>
<td>getToken()</td>
<td>Gets first token in this text</td>
</tr>
<tr>
<td>Text</td>
<td>getWord()</td>
<td>Gets first word in this text</td>
</tr>
<tr>
<td>Text</td>
<td>next(String type)</td>
<td>Gets the next segment of the given type</td>
</tr>
<tr>
<td>Text</td>
<td>next(String type, int nth)</td>
<td>Gets the next nth segment of given type</td>
</tr>
<tr>
<td>Text</td>
<td>nextColumn()</td>
<td>Gets the next column</td>
</tr>
<tr>
<td>Text</td>
<td>nextNumber()</td>
<td>Gets the next number</td>
</tr>
<tr>
<td>Text</td>
<td>nextWord()</td>
<td>Gets the next word</td>
</tr>
<tr>
<td>Text</td>
<td>previous(String type)</td>
<td>Gets the previous segment of the given type</td>
</tr>
<tr>
<td>Text</td>
<td>previous(TextType textType)</td>
<td>Gets the previous segment of the given type</td>
</tr>
<tr>
<td>Text</td>
<td>previousNumber()</td>
<td>Gets the nth previous number</td>
</tr>
<tr>
<td>Text</td>
<td>previousWord()</td>
<td>Gets the nth previous Word</td>
</tr>
<tr>
<td>Text</td>
<td>slice(int start)</td>
<td>Gets a slice of text containing just a substring of getValue() until the end</td>
</tr>
<tr>
<td>Text</td>
<td>up()</td>
<td>Gets segment of previous sibling, where the start and end are the same this text</td>
</tr>
<tr>
<td>TextCollection</td>
<td>getColumns()</td>
<td>Gets collection of columns in this text (segments separated by two spaces)</td>
</tr>
<tr>
<td>TextCollection</td>
<td>getSentences()</td>
<td>Gets this text as a collection of sentences</td>
</tr>
<tr>
<td>TextCollection</td>
<td>getTokens()</td>
<td>Gets this text as a collection of tokens (words but includes punctuation as separate tokens)</td>
</tr>
<tr>
<td>TextCollection</td>
<td>tokenize(String expression)</td>
<td>Tokenizes this text into a collection using the given expression</td>
</tr>
<tr>
<td>TextCollection</td>
<td>tokenizeBySpaces(int numberOfSpaces)</td>
<td>Tokenizes this text by a given number of spaces</td>
</tr>
<tr>
<td>TextCollection</td>
<td>getWords()</td>
<td>Gets this text as a collection of words (excludes punctuation)</td>
</tr>
<tr>
<td>TextCollection</td>
<td>getNumbers()</td>
<td>Gets this text as a collection of numbers</td>
</tr>
<tr>
<td>TextSegment</td>
<td>asTextSegment()</td>
<td>Gets this node as a text segment</td>
</tr>
<tr>
<td>TextType</td>
<td>getTextType()</td>
<td>Gets the type of this text.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-by-num">Navigation by numbers </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description  </th>
</tr>
</thead>
<tbody>
<tr>
<td>BigDecimal</td>
<td>getDecimal()</td>
<td>Gets decimal version of cleaned value</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>toDecimal()</td>
<td>Gets this text as a decimal, 0 if not a decimal</td>
</tr>
<tr>
<td>boolean</td>
<td>isBlank()</td>
<td>Asks if this text is blank</td>
</tr>
<tr>
<td>boolean</td>
<td>isNumeric()</td>
<td>Asks if cleaned value is numeric</td>
</tr>
<tr>
<td>boolean</td>
<td>match(Pattern pattern)</td>
<td>Asks if the given pattern matches getValue()</td>
</tr>
<tr>
<td>boolean</td>
<td>match(TextType textType)</td>
<td>Asks the given type is found inside getValue()  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-by-string">Navigation by string </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>detectPattern()</td>
<td>Gets linguistic pattern of this text, e.g.</td>
</tr>
<tr>
<td>String</td>
<td>extract(String regex)</td>
<td>Extracts regex group from getValue()</td>
</tr>
<tr>
<td>String</td>
<td>formatDate(String pattern)</td>
<td>Formats this text as a date using the given pattern</td>
</tr>
<tr>
<td>String</td>
<td>getCleanedValue()</td>
<td>Gets cleaned value, stripped of unwanted characters</td>
</tr>
<tr>
<td>String</td>
<td>getTrimmedValue()</td>
<td>Gets trimmed value</td>
</tr>
<tr>
<td>String</td>
<td>getValue()</td>
<td>Gets the text value of this item.  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-by-list">Navigation by lists </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>List<characternode></characternode></td>
<td>getChildren()</td>
<td>Gets list of child character nodes</td>
</tr>
<tr>
<td>List<node></node></td>
<td>get(TextType textType)</td>
<td>Get node children that contains the given text type</td>
</tr>
<tr>
<td>List<text></text></td>
<td>get(TextType textType)</td>
<td>Gets all occurrences of type in this text  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h3 id="nav-misc">Misc. Navigation </h3>
<table>
<thead>
<tr>
<th>Navigation Type</th>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date</td>
<td>getDate()</td>
<td>Gets a date representation of getValue()</td>
</tr>
<tr>
<td>PartOfSpeech</td>
<td>getPartOfSpeech()</td>
<td>Gets the granular part of speech of this segment</td>
</tr>
<tr>
<td>SimplePartOfSpeech</td>
<td>getSimplePartOfSpeech()</td>
<td>Gets simplified coarse-grained part of speech  </td>
</tr>
</tbody>
</table>
<p><a href="#top">Top of Section</a></p>
<h2 id="brack-nlp">Some Common Navigation using Brackets and NLP </h2>
<ul>
<li>Brackets [] can be used to get, find or slice items in a node&#x2019;s list of children  </li>
<li>Indexing is 0 based, where first item is always 0  </li>
<li>[&#x2018;0:9&#x2019;] indicates a slice of a collection, e.g. items 0 - 9</li>
<li>The syntax follow a fluent style, where each call returns a node, e.g.  </li>
<li>Everything is zero indexed, meaning 0 is the first, 1 is the second and so on.    </li>
<li>When specifying the first or last characters, a number is not needed, thus [&#x2018;1:&#x2019;] means from second to last, and [&#x2018;:3] would mean from first to 4th.    </li>
<li>Negative integers count backwards from the end of list, with -1 being last item  <ul>
<li>Within brackets that use colons, e.g. [&#x2018;1:3&#x2019;], the last digit is a penultimate digit.  The definition of penultimate is something that is second to last or right before the last item in a series. An example of penultimate is the letter &quot;Y&quot; which is the second to last letter in the alphabet.  If you have a sentence that ends with a period, the penultimate character would be whatever is right before the period.  </li>
</ul>
</li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h3 id="brac-examp">Examples: </h3>
<p>Please remember that this is a condensed list of examples.  For the full listing of available syntax, updated during each PD<sup>3</sup>P build, please refer to the link at the top of this section.</p>
<h4 id="from-root">From root: </h4>
<ul>
<li>[&#x2018;0&#x2019;] - first item in list of children  </li>
<li>[&#x2018;-1&#x2019;] - last item in list of children  </li>
<li>[&#x2018;0:9&#x2019;] - slice of first 10 children  </li>
<li>[&#x2018;Hello&#x2019;] - first direct child node, e.g. paragraph or cell, that contains Hello  </li>
<li>[&#x2018;H\w+o&#x2019;] - first direct child node that contains word beginning with H and ending with o</li>
<li>find(&#x2018;Hello&#x2019;) - first descendant node that contains Hello  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h4 id="from-node">From any node: </h4>
<ul>
<li>go(1) - next adjacent sibling or cousin if no more siblings available</li>
<li>go(-1) - previous adjacent sibling or cousin if no more siblings available</li>
<li>go(2) - forward 2 nodes</li>
<li>go(-2) - backward 2 nodes</li>
<li>parent - parent of the node</li>
<li>findNext(regex, 3) - find next 3rd occurrence of regex from current node</li>
<li>findPrevious(regex, 3) - find previous 3rd occurrence of regex from current node</li>
<li>findNextType(&#x2018;date&#x2019;, 3) - find next 3rd occurrence of a date using NLP</li>
<li>findPreviousType(&#x2018;person&#x2019;) - find previous occurrence of a person name using NLP</li>
<li>findNextType(&#x2018;organization&#x2019;, 3) - find next 3rd occurrence of an organization name using NLP  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h4 id="from-text-node">From any text node (paragraph, cell or extracted text segment): </h4>
<ul>
<li>[&#x2018;0:9&#x2019;] - first 10 characters of paragraph</li>
<li>[&#x2018;-10:-1&#x2019;] - last 10 characters of paragraph
0    extract(&#x2018;Name: (.*)&#x2019;) - extract name using regex grouping</li>
<li>tokens - list of tokens (text segments, words or punctuation, needs work)</li>
<li>token - first token in the node</li>
<li>sentences - list of sentences (text segments) in the node</li>
<li>sentence - first sentence in the node</li>
<li>persons - list of persons (text segments) in the node</li>
<li>person - first person in the node</li>
<li>organizations - list of organizations (text segments) in the node</li>
<li>organization - first organization in the node</li>
<li>dates - list of dates (text segments) in the node</li>
<li>date - first date in the node  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h4 id="from-table">From tables: </h4>
<ul>
<li>[&#x2018;0&#x2019;] - first row</li>
<li>[&#x2018;0&#x2019;][&#x2018;0&#x2019;] - first row, first cell</li>
<li>[&#x2018;0:9&#x2019;] - slice of first 10 rows  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h4 id="from-rows">From rows: </h4>
<ul>
<li>[&#x2018;0&#x2019;] - first cell in row</li>
<li>[&#x2018;0:9&#x2019;] - slice of first 10 cells  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h4 id="from-cells">From cells: </h4>
<ul>
<li>[&#x2018;0:9&#x2019;] - slice of first 10 characters in cell</li>
<li>extract(&#x2018;Credit Score: (.*)&#x2019;) - extract credit score using regex grouping</li>
<li>go(1,1) - navigate one cell to right and one cell down</li>
<li>go(-1,-1) - navigate one cell to left and one cell up</li>
<li>row[&#x2018;0&#x2019;] - retrieve to first cell in current row</li>
<li>row[&#x2018;-1&#x2019;] - retrieve last cell in current row  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h1 id="advanced-nav-feat">Advanced Navigation Features </h1>
<h2 id="java-var">JAVA Variable Declarations </h2>
<p>The Pendo Digital Pendo Digital Data Discovery Platform allows you to make use of JAVA objects within the Mapping expressions. This powerful feature gives you more flexibility in deriving values from unstructured data. Examples include:</p>
<ul>
<li>Enhanced, type-safe parsing.</li>
<li>Date parsing, conversion and arithmetic.</li>
<li>String manipulation and formatting capabilities.  </li>
</ul>
<p><a href="#top">Top of Section</a></p>
<h3 id="java-declare">Declaring a variable </h3>
<p>Variables are declared using the standard java syntax. For example:  </p>
<p>new java.math.BigDecimal(&#x201C;999&#x201D;)<br>Would declare an anonymous variable with the value of 999.<br>A more useful example would be to convert a value extracted from a document into a JAVA BigDecimal:<br>new java.math.BigDecimal(getSheet(&#x201C;Sheet1&#x201D;).getCellByXY(3,6).value)<br>This example extracts the contents of the cell in Row 3 and Column 6 from Sheet1 of an Excel workbook into a BigDecimal.  If the cell does not contain a valid string value that cannot be parsed into a BigDecimal, the Pendo Digital Data Discovery Platform will report an Error.  </p>
<p><a href="#top">Top of Section</a></p>
<h3 id="java-parse">Date Parsing and Date Arithmetic </h3>
<p>A common use of variable declaration is to convert string text into an object of a given type. A quite common technique is to parse a string into a date variable. This is done by using the JAVA SimpleDateFormat class. As the following example demonstrates, a string value is parsed into a date object:<br>new java.text.SimpleDateFormat(&#x201C;dd MMMMM, yyyy&#x201D;).parse(#cell.value)<br>When you declare the SimpleDateFormat variable, you supply the format of the string date to parse. In the example above, the MMMMM represents a long description of a month (e.g. January, February, etc), when the cell is parsed, a Date variable is created from the string text.
Now that you have a date value, you can use a second SimpleDateFormat object to output the date as a string in the format you would like. For example:</p>
<table>
<thead>
<tr>
<th>Input variable</th>
<th>#cell.value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input value</td>
<td>29 February, 2016</td>
</tr>
<tr>
<td>Expression</td>
<td>new java.text.SimpleDateFormat(&#x201C;MM/dd/yyyy&#x201D;).format(new java.text.SimpleDateFormat(&#x201C;dd MMMMM, yyyy&#x201D;).parse(#cell.value))</td>
</tr>
<tr>
<td>Output</td>
<td>02/29/2016</td>
</tr>
</tbody>
</table>
<p>Once you have parsed a value into a Date, you can perform date arithmetic by using Pendo&#x2019;s DateHelper object. This is instantiated by passing a JAVA date in the constructor. Using the last example as a starting point, say you need to add one month to the date you just parsed. This can be accomplished using the following expression:  </p>
<table>
<thead>
<tr>
<th>Input variable</th>
<th>#cell.value  </th>
</tr>
</thead>
<tbody>
<tr>
<td>Input value</td>
<td>29 February, 2016</td>
</tr>
<tr>
<td>Expression</td>
<td>new com.pendosystems.DateHelper(new java.text.SimpleDateFormat(&#x201C;MM/dd/yyyy&#x201D;).format(new java.text.SimpleDateFormat(&#x201C;dd MMMMM, yyyy&#x201D;).parse(#cell.value))).addMonth(1).format()</td>
</tr>
<tr>
<td>Output</td>
<td>03/29/2016</td>
</tr>
</tbody>
</table>
<p>For more information on the SimpleDateFormat class, refer to the JAVA documentation at :JAVA Documentation.<br>For more information about the DateHelper class, refer to the Pendo Systems User Guide.  </p>
<p><a href="#top">Top of Section</a></p>
<h3 id="java-branch">Conditional Branching </h3>
<p>The Pendo mapping syntax allows you to perform logical tests on the data in the document to determine if a certain state is true or false and then branch to different mapping logic based upon the outcome. This is very useful when the format of the document has changed over time and you can test for the existence (or absence) of a specific value.<br>For example, imagine that a document, in this case an Excel workbook, sometimes does, or does not contain a line item showing the current outstanding balance of loans (see below).
The document sometimes has the following rows of data:</p>
<table>
<thead>
<tr>
<th>Outstanding Balance</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Current</td>
<td>120,000.00</td>
</tr>
<tr>
<td>1-30 Days</td>
<td>80,000.00</td>
</tr>
<tr>
<td>31-60 Days</td>
<td>60,000.00</td>
</tr>
<tr>
<td>61-90 Days</td>
<td>40,000.00</td>
</tr>
<tr>
<td>Total</td>
<td>200,000.00</td>
</tr>
</tbody>
</table>
<p>But sometimes the Current balance is not included:  </p>
<table>
<thead>
<tr>
<th>Outstanding Balance</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1-30 Days</td>
<td>80,000.00</td>
</tr>
<tr>
<td>31-60 Days</td>
<td>60,000.00</td>
</tr>
<tr>
<td>61-90 Days</td>
<td>40,000.00</td>
</tr>
<tr>
<td>Total</td>
<td>180,000.00</td>
</tr>
</tbody>
</table>
<p>If you have to get the balance of all current loans, you need to be able to test for the presence of it. In order to do so, we use the ternary expression:<br>Test Expression ? Perform if True : Perform if false  </p>
<p>Using the example above, we could write the following:<br>getSheet(&#x201C;.*&#x201D;).find(&#x201C;Outstatnding Balance&#x201D; ).down().value == &#x201C;Current&#x201D;?getSheet(&#x201C;.*&#x201D;).find(&#x201C;Outstatnding Balance&#x201D; ).down().rightWithContent().decimal:
New java.math.BigDecimal(&#x201C;0.0&#x201D;)</p>
<p>This expression tests to see if the value in the cell below &#x201C;Outstanding Balance&#x201D; is the current segment, if it is, then get the value to the right of the cell as the current balance, if it is not, return 0.  </p>
<p><a href="#top">Top of Section</a></p>
<h3 id="elvis">The Elvis Operator </h3>
<p>Pendo provides a shorthand form of the ternary statement known as the Elvis Operator. This term has the syntax ?: and it returns the outcome of the test expression if the statement is true and the expression after the operator if false. For example:
find(&#x201C;Outstanding Balance&#x201D; ).rightWithContent().value ?: &#x201C;0.0&#x201D;
This expression would return the value to the right of the cell containing the words &#x201C;Outstanding Balance&#x201D;, or it would return a string value of &#x201C;0.0&#x201D;.  </p>
<p><a href="#top">Top of Section</a></p>
<h3 id="safe">Safe Navigation </h3>
<p>Pendo allows you to test for an expression, rather than throwing an error by using the safe navigation operator. For example, using the example above when searching for the current balance. You can test that the cell with the word &#x201C;Current&#x201D; is in the sheet directly, without triggering an error if it is not found. The usual syntax of:  </p>
<p>getSheet(&#x201C;.*&#x201D;).find(&#x201C;Current&#x201D;).rightWithContent().value
Would throw an error of &#x201C;Unable to process expression value on object [null]&#x201D;.<br>However, by placing a question mark (?) after the find operation, and every operation following it in the expression, would test the expression and not throw the error if the value was not found:<br>getSheet(&#x201C;.*&#x201D;).find(&#x201C;Current&#x201D;)?.rightWithContent()?.value<br>This would return null (an empty string) if the segment was not found.  </p>
<p><a href="#top">Top of Section</a></p>
<h1 id="spEl">spEl Examples </h1>
<p><a href="#top">Top of Section</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="appendix_plugins.html#top" class="navigation navigation-prev " aria-label="Previous page: Appendix – Data Plugins - General Information">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="appendix_using_fixed_values.html#top" class="navigation navigation-next " aria-label="Next page: Appendix – Using Fixed Values including Approved List of Values during Classification Mapping">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Appendix - Non- and Semi-Structured Document Navigation","level":"1.8","depth":1,"next":{"title":"Appendix – Using Fixed Values including Approved List of Values during Classification Mapping","level":"1.9","depth":1,"anchor":"#top","path":"appendix_using_fixed_values.md","ref":"appendix_using_fixed_values.md#top","articles":[]},"previous":{"title":"Appendix – Data Plugins - General Information","level":"1.7","depth":1,"anchor":"#top","path":"appendix_plugins.md","ref":"appendix_plugins.md#top","articles":[]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["heading-anchors"],"pluginsConfig":{"heading-anchors":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"appendix_document_navigation.md","mtime":"2017-09-07T14:36:58.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2017-12-08T21:25:59.184Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/1.2.1/anchor.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-heading-anchors/anchor-style.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

